/*! 
* Copyright (c) Tiny Technologies, Inc. All rights reserved.
* Licensed under the LGPL or a commercial license.
* For LGPL see License.txt in the project root for license information.
* For commercial licenses see https://www.tiny.cloud/
* 
*  Version: 5.7.0 (2021-02-10)
*  */
!function(r){var t={};function o(n){if(t[n])return t[n].exports;var e=t[n]={i:n,l:!1,exports:{}};return r[n].call(e.exports,e,e.exports,o),e.l=!0,e.exports}o.m=r,o.c=t,o.d=function(n,e,r){o.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:r})},o.r=function(n){Object.defineProperty(n,"__esModule",{value:!0})},o.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="",o(o.s="./src/js/plugins/save/plugin.js")}({"./src/js/plugins/save/plugin.js":function(module,exports){eval("/**\n  * Copyright (c) Tiny Technologies, Inc. All rights reserved.\n  * Licensed under the LGPL or a commercial license.\n  * For LGPL see License.txt in the project root for license information.\n  * For commercial licenses see https://www.tiny.cloud/\n  *\n  * Version: 5.7.0 (2021-02-10)\n  */\n (function () {\n    'use strict';\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    var enableWhenDirty = function (editor) {\n      return editor.getParam('save_enablewhendirty', true);\n    };\n    var hasOnSaveCallback = function (editor) {\n      return !!editor.getParam('save_onsavecallback');\n    };\n    var hasOnCancelCallback = function (editor) {\n      return !!editor.getParam('save_oncancelcallback');\n    };\n\n    var displayErrorMessage = function (editor, message) {\n      editor.notificationManager.open({\n        text: message,\n        type: 'error'\n      });\n    };\n    var save = function (editor) {\n      var formObj = global$1.DOM.getParent(editor.id, 'form');\n      if (enableWhenDirty(editor) && !editor.isDirty()) {\n        return;\n      }\n      editor.save();\n      if (hasOnSaveCallback(editor)) {\n        editor.execCallback('save_onsavecallback', editor);\n        editor.nodeChanged();\n        return;\n      }\n      if (formObj) {\n        editor.setDirty(false);\n        if (!formObj.onsubmit || formObj.onsubmit()) {\n          if (typeof formObj.submit === 'function') {\n            formObj.submit();\n          } else {\n            displayErrorMessage(editor, 'Error: Form submit field collision.');\n          }\n        }\n        editor.nodeChanged();\n      } else {\n        displayErrorMessage(editor, 'Error: No form element found.');\n      }\n    };\n    var cancel = function (editor) {\n      var h = global$2.trim(editor.startContent);\n      if (hasOnCancelCallback(editor)) {\n        editor.execCallback('save_oncancelcallback', editor);\n        return;\n      }\n      editor.resetContent(h);\n    };\n\n    var register = function (editor) {\n      editor.addCommand('mceSave', function () {\n        save(editor);\n      });\n      editor.addCommand('mceCancel', function () {\n        cancel(editor);\n      });\n    };\n\n    var stateToggle = function (editor) {\n      return function (api) {\n        var handler = function () {\n          api.setDisabled(enableWhenDirty(editor) && !editor.isDirty());\n        };\n        editor.on('NodeChange dirty', handler);\n        return function () {\n          return editor.off('NodeChange dirty', handler);\n        };\n      };\n    };\n    var register$1 = function (editor) {\n      editor.ui.registry.addButton('save', {\n        icon: 'save',\n        tooltip: 'Save',\n        disabled: true,\n        onAction: function () {\n          return editor.execCommand('mceSave');\n        },\n        onSetup: stateToggle(editor)\n      });\n      editor.ui.registry.addButton('cancel', {\n        icon: 'cancel',\n        tooltip: 'Cancel',\n        disabled: true,\n        onAction: function () {\n          return editor.execCommand('mceCancel');\n        },\n        onSetup: stateToggle(editor)\n      });\n      editor.addShortcut('Meta+S', '', 'mceSave');\n    };\n\n    function Plugin () {\n      global.add('save', function (editor) {\n        register$1(editor);\n        register(editor);\n      });\n    }\n\n    Plugin();\n\n}());\n\n\n//# sourceURL=webpack:///./src/js/plugins/save/plugin.js?")}});