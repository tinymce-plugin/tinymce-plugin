/*! 
* Copyright (c) Tiny Technologies, Inc. All rights reserved.
* Licensed under the LGPL or a commercial license.
* For LGPL see License.txt in the project root for license information.
* For commercial licenses see https://www.tiny.cloud/
* 
*  Version: 5.7.0 (2021-02-10)
*  */
!function(t){var r={};function a(n){if(r[n])return r[n].exports;var e=r[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,a),e.l=!0,e.exports}a.m=t,a.c=r,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:t})},a.r=function(n){Object.defineProperty(n,"__esModule",{value:!0})},a.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="",a(a.s="./src/js/plugins/codesample/plugin.js")}({"./src/js/plugins/codesample/plugin.js":function(module,exports){eval("/**\n  * Copyright (c) Tiny Technologies, Inc. All rights reserved.\n  * Licensed under the LGPL or a commercial license.\n  * For LGPL see License.txt in the project root for license information.\n  * For commercial licenses see https://www.tiny.cloud/\n  *\n  * Version: 5.7.0 (2021-02-10)\n  */\n (function () {\n    'use strict';\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    var noop = function () {\n    };\n    var constant = function (value) {\n      return function () {\n        return value;\n      };\n    };\n    var never = constant(false);\n    var always = constant(true);\n\n    var none = function () {\n      return NONE;\n    };\n    var NONE = function () {\n      var eq = function (o) {\n        return o.isNone();\n      };\n      var call = function (thunk) {\n        return thunk();\n      };\n      var id = function (n) {\n        return n;\n      };\n      var me = {\n        fold: function (n, _s) {\n          return n();\n        },\n        is: never,\n        isSome: never,\n        isNone: always,\n        getOr: id,\n        getOrThunk: call,\n        getOrDie: function (msg) {\n          throw new Error(msg || 'error: getOrDie called on none.');\n        },\n        getOrNull: constant(null),\n        getOrUndefined: constant(undefined),\n        or: id,\n        orThunk: call,\n        map: none,\n        each: noop,\n        bind: none,\n        exists: never,\n        forall: always,\n        filter: none,\n        equals: eq,\n        equals_: eq,\n        toArray: function () {\n          return [];\n        },\n        toString: constant('none()')\n      };\n      return me;\n    }();\n    var some = function (a) {\n      var constant_a = constant(a);\n      var self = function () {\n        return me;\n      };\n      var bind = function (f) {\n        return f(a);\n      };\n      var me = {\n        fold: function (n, s) {\n          return s(a);\n        },\n        is: function (v) {\n          return a === v;\n        },\n        isSome: always,\n        isNone: never,\n        getOr: constant_a,\n        getOrThunk: constant_a,\n        getOrDie: constant_a,\n        getOrNull: constant_a,\n        getOrUndefined: constant_a,\n        or: self,\n        orThunk: self,\n        map: function (f) {\n          return some(f(a));\n        },\n        each: function (f) {\n          f(a);\n        },\n        bind: bind,\n        exists: bind,\n        forall: bind,\n        filter: function (f) {\n          return f(a) ? me : NONE;\n        },\n        toArray: function () {\n          return [a];\n        },\n        toString: function () {\n          return 'some(' + a + ')';\n        },\n        equals: function (o) {\n          return o.is(a);\n        },\n        equals_: function (o, elementEq) {\n          return o.fold(never, function (b) {\n            return elementEq(a, b);\n          });\n        }\n      };\n      return me;\n    };\n    var from = function (value) {\n      return value === null || value === undefined ? NONE : some(value);\n    };\n    var Optional = {\n      some: some,\n      none: none,\n      from: from\n    };\n\n    var get = function (xs, i) {\n      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    };\n    var head = function (xs) {\n      return get(xs, 0);\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var isCodeSample = function (elm) {\n      return elm && elm.nodeName === 'PRE' && elm.className.indexOf('language-') !== -1;\n    };\n    var trimArg = function (predicateFn) {\n      return function (arg1, arg2) {\n        return predicateFn(arg2);\n      };\n    };\n\n    var Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    var exports$1 = {}, module = { exports: exports$1 }, global$2 = {};\n    (function (define, exports, module, require) {\n      var oldprism = window.Prism;\n      window.Prism = { manual: true };\n      (function (f) {\n        if (typeof exports === 'object' && typeof module !== 'undefined') {\n          module.exports = f();\n        } else if (typeof define === 'function' && define.amd) {\n          define([], f);\n        } else {\n          var g;\n          if (typeof window !== 'undefined') {\n            g = window;\n          } else if (typeof global$2 !== 'undefined') {\n            g = global$2;\n          } else if (typeof self !== 'undefined') {\n            g = self;\n          } else {\n            g = this;\n          }\n          g.EphoxContactWrapper = f();\n        }\n      }(function () {\n        return function () {\n          function r(e, n, t) {\n            function o(i, f) {\n              if (!n[i]) {\n                if (!e[i]) {\n                  var c = 'function' == typeof require && require;\n                  if (!f && c)\n                    return c(i, !0);\n                  if (u)\n                    return u(i, !0);\n                  var a = new Error('Cannot find module \\'' + i + '\\'');\n                  throw a.code = 'MODULE_NOT_FOUND', a;\n                }\n                var p = n[i] = { exports: {} };\n                e[i][0].call(p.exports, function (r) {\n                  var n = e[i][1][r];\n                  return o(n || r);\n                }, p, p.exports, r, e, n, t);\n              }\n              return n[i].exports;\n            }\n            for (var u = 'function' == typeof require && require, i = 0; i < t.length; i++)\n              o(t[i]);\n            return o;\n          }\n          return r;\n        }()({\n          1: [\n            function (require, module, exports) {\n              Prism.languages.c = Prism.languages.extend('clike', {\n                'comment': {\n                  pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n                  greedy: true\n                },\n                'class-name': {\n                  pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n                  lookbehind: true\n                },\n                'keyword': /\\b(?:__attribute__|_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\\b/,\n                'function': /[a-z_]\\w*(?=\\s*\\()/i,\n                'number': /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n                'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n              });\n              Prism.languages.insertBefore('c', 'string', {\n                'macro': {\n                  pattern: /(^\\s*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n                  lookbehind: true,\n                  greedy: true,\n                  alias: 'property',\n                  inside: {\n                    'string': [\n                      {\n                        pattern: /^(#\\s*include\\s*)<[^>]+>/,\n                        lookbehind: true\n                      },\n                      Prism.languages.c['string']\n                    ],\n                    'comment': Prism.languages.c['comment'],\n                    'macro-name': [\n                      {\n                        pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n                        lookbehind: true\n                      },\n                      {\n                        pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n                        lookbehind: true,\n                        alias: 'function'\n                      }\n                    ],\n                    'directive': {\n                      pattern: /^(#\\s*)[a-z]+/,\n                      lookbehind: true,\n                      alias: 'keyword'\n                    },\n                    'directive-hash': /^#/,\n                    'punctuation': /##|\\\\(?=[\\r\\n])/,\n                    'expression': {\n                      pattern: /\\S[\\s\\S]*/,\n                      inside: Prism.languages.c\n                    }\n                  }\n                },\n                'constant': /\\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\\b/\n              });\n              delete Prism.languages.c['boolean'];\n            },\n            {}\n          ],\n          2: [\n            function (require, module, exports) {\n              Prism.languages.clike = {\n                'comment': [\n                  {\n                    pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n                    lookbehind: true,\n                    greedy: true\n                  },\n                  {\n                    pattern: /(^|[^\\\\:])\\/\\/.*/,\n                    lookbehind: true,\n                    greedy: true\n                  }\n                ],\n                'string': {\n                  pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n                  greedy: true\n                },\n                'class-name': {\n                  pattern: /(\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n                  lookbehind: true,\n                  inside: { 'punctuation': /[.\\\\]/ }\n                },\n                'keyword': /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n                'boolean': /\\b(?:true|false)\\b/,\n                'function': /\\w+(?=\\()/,\n                'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n                'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n                'punctuation': /[{}[\\];(),.:]/\n              };\n            },\n            {}\n          ],\n          3: [\n            function (require, module, exports) {\n              (function (global) {\n                (function () {\n                  var _self = typeof window !== 'undefined' ? window : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : {};\n                  var Prism = function (_self) {\n                    var lang = /\\blang(?:uage)?-([\\w-]+)\\b/i;\n                    var uniqueId = 0;\n                    var _ = {\n                      manual: _self.Prism && _self.Prism.manual,\n                      disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n                      util: {\n                        encode: function encode(tokens) {\n                          if (tokens instanceof Token) {\n                            return new Token(tokens.type, encode(tokens.content), tokens.alias);\n                          } else if (Array.isArray(tokens)) {\n                            return tokens.map(encode);\n                          } else {\n                            return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n                          }\n                        },\n                        type: function (o) {\n                          return Object.prototype.toString.call(o).slice(8, -1);\n                        },\n                        objId: function (obj) {\n                          if (!obj['__id']) {\n                            Object.defineProperty(obj, '__id', { value: ++uniqueId });\n                          }\n                          return obj['__id'];\n                        },\n                        clone: function deepClone(o, visited) {\n                          visited = visited || {};\n                          var clone, id;\n                          switch (_.util.type(o)) {\n                          case 'Object':\n                            id = _.util.objId(o);\n                            if (visited[id]) {\n                              return visited[id];\n                            }\n                            clone = {};\n                            visited[id] = clone;\n                            for (var key in o) {\n                              if (o.hasOwnProperty(key)) {\n                                clone[key] = deepClone(o[key], visited);\n                              }\n                            }\n                            return clone;\n                          case 'Array':\n                            id = _.util.objId(o);\n                            if (visited[id]) {\n                              return visited[id];\n                            }\n                            clone = [];\n                            visited[id] = clone;\n                            o.forEach(function (v, i) {\n                              clone[i] = deepClone(v, visited);\n                            });\n                            return clone;\n                          default:\n                            return o;\n                          }\n                        },\n                        getLanguage: function (element) {\n                          while (element && !lang.test(element.className)) {\n                            element = element.parentElement;\n                          }\n                          if (element) {\n                            return (element.className.match(lang) || [\n                              ,\n                              'none'\n                            ])[1].toLowerCase();\n                          }\n                          return 'none';\n                        },\n                        currentScript: function () {\n                          if (typeof document === 'undefined') {\n                            return null;\n                          }\n                          if ('currentScript' in document && 1 < 2) {\n                            return document.currentScript;\n                          }\n                          try {\n                            throw new Error();\n                          } catch (err) {\n                            var src = (/at [^(\\r\\n]*\\((.*):.+:.+\\)$/i.exec(err.stack) || [])[1];\n                            if (src) {\n                              var scripts = document.getElementsByTagName('script');\n                              for (var i in scripts) {\n                                if (scripts[i].src == src) {\n                                  return scripts[i];\n                                }\n                              }\n                            }\n                            return null;\n                          }\n                        },\n                        isActive: function (element, className, defaultActivation) {\n                          var no = 'no-' + className;\n                          while (element) {\n                            var classList = element.classList;\n                            if (classList.contains(className)) {\n                              return true;\n                            }\n                            if (classList.contains(no)) {\n                              return false;\n                            }\n                            element = element.parentElement;\n                          }\n                          return !!defaultActivation;\n                        }\n                      },\n                      languages: {\n                        extend: function (id, redef) {\n                          var lang = _.util.clone(_.languages[id]);\n                          for (var key in redef) {\n                            lang[key] = redef[key];\n                          }\n                          return lang;\n                        },\n                        insertBefore: function (inside, before, insert, root) {\n                          root = root || _.languages;\n                          var grammar = root[inside];\n                          var ret = {};\n                          for (var token in grammar) {\n                            if (grammar.hasOwnProperty(token)) {\n                              if (token == before) {\n                                for (var newToken in insert) {\n                                  if (insert.hasOwnProperty(newToken)) {\n                                    ret[newToken] = insert[newToken];\n                                  }\n                                }\n                              }\n                              if (!insert.hasOwnProperty(token)) {\n                                ret[token] = grammar[token];\n                              }\n                            }\n                          }\n                          var old = root[inside];\n                          root[inside] = ret;\n                          _.languages.DFS(_.languages, function (key, value) {\n                            if (value === old && key != inside) {\n                              this[key] = ret;\n                            }\n                          });\n                          return ret;\n                        },\n                        DFS: function DFS(o, callback, type, visited) {\n                          visited = visited || {};\n                          var objId = _.util.objId;\n                          for (var i in o) {\n                            if (o.hasOwnProperty(i)) {\n                              callback.call(o, i, o[i], type || i);\n                              var property = o[i], propertyType = _.util.type(property);\n                              if (propertyType === 'Object' && !visited[objId(property)]) {\n                                visited[objId(property)] = true;\n                                DFS(property, callback, null, visited);\n                              } else if (propertyType === 'Array' && !visited[objId(property)]) {\n                                visited[objId(property)] = true;\n                                DFS(property, callback, i, visited);\n                              }\n                            }\n                          }\n                        }\n                      },\n                      plugins: {},\n                      highlightAll: function (async, callback) {\n                        _.highlightAllUnder(document, async, callback);\n                      },\n                      highlightAllUnder: function (container, async, callback) {\n                        var env = {\n                          callback: callback,\n                          container: container,\n                          selector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n                        };\n                        _.hooks.run('before-highlightall', env);\n                        env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n                        _.hooks.run('before-all-elements-highlight', env);\n                        for (var i = 0, element; element = env.elements[i++];) {\n                          _.highlightElement(element, async === true, env.callback);\n                        }\n                      },\n                      highlightElement: function (element, async, callback) {\n                        var language = _.util.getLanguage(element);\n                        var grammar = _.languages[language];\n                        element.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n                        var parent = element.parentElement;\n                        if (parent && parent.nodeName.toLowerCase() === 'pre') {\n                          parent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n                        }\n                        var code = element.textContent;\n                        var env = {\n                          element: element,\n                          language: language,\n                          grammar: grammar,\n                          code: code\n                        };\n                        function insertHighlightedCode(highlightedCode) {\n                          env.highlightedCode = highlightedCode;\n                          _.hooks.run('before-insert', env);\n                          env.element.innerHTML = env.highlightedCode;\n                          _.hooks.run('after-highlight', env);\n                          _.hooks.run('complete', env);\n                          callback && callback.call(env.element);\n                        }\n                        _.hooks.run('before-sanity-check', env);\n                        if (!env.code) {\n                          _.hooks.run('complete', env);\n                          callback && callback.call(env.element);\n                          return;\n                        }\n                        _.hooks.run('before-highlight', env);\n                        if (!env.grammar) {\n                          insertHighlightedCode(_.util.encode(env.code));\n                          return;\n                        }\n                        if (async && _self.Worker) {\n                          var worker = new Worker(_.filename);\n                          worker.onmessage = function (evt) {\n                            insertHighlightedCode(evt.data);\n                          };\n                          worker.postMessage(JSON.stringify({\n                            language: env.language,\n                            code: env.code,\n                            immediateClose: true\n                          }));\n                        } else {\n                          insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n                        }\n                      },\n                      highlight: function (text, grammar, language) {\n                        var env = {\n                          code: text,\n                          grammar: grammar,\n                          language: language\n                        };\n                        _.hooks.run('before-tokenize', env);\n                        env.tokens = _.tokenize(env.code, env.grammar);\n                        _.hooks.run('after-tokenize', env);\n                        return Token.stringify(_.util.encode(env.tokens), env.language);\n                      },\n                      tokenize: function (text, grammar) {\n                        var rest = grammar.rest;\n                        if (rest) {\n                          for (var token in rest) {\n                            grammar[token] = rest[token];\n                          }\n                          delete grammar.rest;\n                        }\n                        var tokenList = new LinkedList();\n                        addAfter(tokenList, tokenList.head, text);\n                        matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n                        return toArray(tokenList);\n                      },\n                      hooks: {\n                        all: {},\n                        add: function (name, callback) {\n                          var hooks = _.hooks.all;\n                          hooks[name] = hooks[name] || [];\n                          hooks[name].push(callback);\n                        },\n                        run: function (name, env) {\n                          var callbacks = _.hooks.all[name];\n                          if (!callbacks || !callbacks.length) {\n                            return;\n                          }\n                          for (var i = 0, callback; callback = callbacks[i++];) {\n                            callback(env);\n                          }\n                        }\n                      },\n                      Token: Token\n                    };\n                    _self.Prism = _;\n                    function Token(type, content, alias, matchedStr) {\n                      this.type = type;\n                      this.content = content;\n                      this.alias = alias;\n                      this.length = (matchedStr || '').length | 0;\n                    }\n                    Token.stringify = function stringify(o, language) {\n                      if (typeof o == 'string') {\n                        return o;\n                      }\n                      if (Array.isArray(o)) {\n                        var s = '';\n                        o.forEach(function (e) {\n                          s += stringify(e, language);\n                        });\n                        return s;\n                      }\n                      var env = {\n                        type: o.type,\n                        content: stringify(o.content, language),\n                        tag: 'span',\n                        classes: [\n                          'token',\n                          o.type\n                        ],\n                        attributes: {},\n                        language: language\n                      };\n                      var aliases = o.alias;\n                      if (aliases) {\n                        if (Array.isArray(aliases)) {\n                          Array.prototype.push.apply(env.classes, aliases);\n                        } else {\n                          env.classes.push(aliases);\n                        }\n                      }\n                      _.hooks.run('wrap', env);\n                      var attributes = '';\n                      for (var name in env.attributes) {\n                        attributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n                      }\n                      return '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n                    };\n                    function matchPattern(pattern, pos, text, lookbehind) {\n                      pattern.lastIndex = pos;\n                      var match = pattern.exec(text);\n                      if (match && lookbehind && match[1]) {\n                        var lookbehindLength = match[1].length;\n                        match.index += lookbehindLength;\n                        match[0] = match[0].slice(lookbehindLength);\n                      }\n                      return match;\n                    }\n                    function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n                      for (var token in grammar) {\n                        if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n                          continue;\n                        }\n                        var patterns = grammar[token];\n                        patterns = Array.isArray(patterns) ? patterns : [patterns];\n                        for (var j = 0; j < patterns.length; ++j) {\n                          if (rematch && rematch.cause == token + ',' + j) {\n                            return;\n                          }\n                          var patternObj = patterns[j], inside = patternObj.inside, lookbehind = !!patternObj.lookbehind, greedy = !!patternObj.greedy, alias = patternObj.alias;\n                          if (greedy && !patternObj.pattern.global) {\n                            var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n                            patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n                          }\n                          var pattern = patternObj.pattern || patternObj;\n                          for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {\n                            if (rematch && pos >= rematch.reach) {\n                              break;\n                            }\n                            var str = currentNode.value;\n                            if (tokenList.length > text.length) {\n                              return;\n                            }\n                            if (str instanceof Token) {\n                              continue;\n                            }\n                            var removeCount = 1;\n                            var match;\n                            if (greedy) {\n                              match = matchPattern(pattern, pos, text, lookbehind);\n                              if (!match) {\n                                break;\n                              }\n                              var from = match.index;\n                              var to = match.index + match[0].length;\n                              var p = pos;\n                              p += currentNode.value.length;\n                              while (from >= p) {\n                                currentNode = currentNode.next;\n                                p += currentNode.value.length;\n                              }\n                              p -= currentNode.value.length;\n                              pos = p;\n                              if (currentNode.value instanceof Token) {\n                                continue;\n                              }\n                              for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {\n                                removeCount++;\n                                p += k.value.length;\n                              }\n                              removeCount--;\n                              str = text.slice(pos, p);\n                              match.index -= pos;\n                            } else {\n                              match = matchPattern(pattern, 0, str, lookbehind);\n                              if (!match) {\n                                continue;\n                              }\n                            }\n                            var from = match.index, matchStr = match[0], before = str.slice(0, from), after = str.slice(from + matchStr.length);\n                            var reach = pos + str.length;\n                            if (rematch && reach > rematch.reach) {\n                              rematch.reach = reach;\n                            }\n                            var removeFrom = currentNode.prev;\n                            if (before) {\n                              removeFrom = addAfter(tokenList, removeFrom, before);\n                              pos += before.length;\n                            }\n                            removeRange(tokenList, removeFrom, removeCount);\n                            var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n                            currentNode = addAfter(tokenList, removeFrom, wrapped);\n                            if (after) {\n                              addAfter(tokenList, currentNode, after);\n                            }\n                            if (removeCount > 1) {\n                              matchGrammar(text, tokenList, grammar, currentNode.prev, pos, {\n                                cause: token + ',' + j,\n                                reach: reach\n                              });\n                            }\n                          }\n                        }\n                      }\n                    }\n                    function LinkedList() {\n                      var head = {\n                        value: null,\n                        prev: null,\n                        next: null\n                      };\n                      var tail = {\n                        value: null,\n                        prev: head,\n                        next: null\n                      };\n                      head.next = tail;\n                      this.head = head;\n                      this.tail = tail;\n                      this.length = 0;\n                    }\n                    function addAfter(list, node, value) {\n                      var next = node.next;\n                      var newNode = {\n                        value: value,\n                        prev: node,\n                        next: next\n                      };\n                      node.next = newNode;\n                      next.prev = newNode;\n                      list.length++;\n                      return newNode;\n                    }\n                    function removeRange(list, node, count) {\n                      var next = node.next;\n                      for (var i = 0; i < count && next !== list.tail; i++) {\n                        next = next.next;\n                      }\n                      node.next = next;\n                      next.prev = node;\n                      list.length -= i;\n                    }\n                    function toArray(list) {\n                      var array = [];\n                      var node = list.head.next;\n                      while (node !== list.tail) {\n                        array.push(node.value);\n                        node = node.next;\n                      }\n                      return array;\n                    }\n                    if (!_self.document) {\n                      if (!_self.addEventListener) {\n                        return _;\n                      }\n                      if (!_.disableWorkerMessageHandler) {\n                        _self.addEventListener('message', function (evt) {\n                          var message = JSON.parse(evt.data), lang = message.language, code = message.code, immediateClose = message.immediateClose;\n                          _self.postMessage(_.highlight(code, _.languages[lang], lang));\n                          if (immediateClose) {\n                            _self.close();\n                          }\n                        }, false);\n                      }\n                      return _;\n                    }\n                    var script = _.util.currentScript();\n                    if (script) {\n                      _.filename = script.src;\n                      if (script.hasAttribute('data-manual')) {\n                        _.manual = true;\n                      }\n                    }\n                    function highlightAutomaticallyCallback() {\n                      if (!_.manual) {\n                        _.highlightAll();\n                      }\n                    }\n                    if (!_.manual) {\n                      var readyState = document.readyState;\n                      if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n                        document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n                      } else {\n                        if (window.requestAnimationFrame) {\n                          window.requestAnimationFrame(highlightAutomaticallyCallback);\n                        } else {\n                          window.setTimeout(highlightAutomaticallyCallback, 16);\n                        }\n                      }\n                    }\n                    return _;\n                  }(_self);\n                  if (typeof module !== 'undefined' && module.exports) {\n                    module.exports = Prism;\n                  }\n                  if (typeof global !== 'undefined') {\n                    global.Prism = Prism;\n                  }\n                }.call(this));\n              }.call(this, typeof global$2 !== 'undefined' ? global$2 : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));\n            },\n            {}\n          ],\n          4: [\n            function (require, module, exports) {\n              (function (Prism) {\n                var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n                Prism.languages.cpp = Prism.languages.extend('c', {\n                  'class-name': [\n                    {\n                      pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n                        return keyword.source;\n                      })),\n                      lookbehind: true\n                    },\n                    /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n                    /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n                    /\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n                  ],\n                  'keyword': keyword,\n                  'number': {\n                    pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n                    greedy: true\n                  },\n                  'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n                  'boolean': /\\b(?:true|false)\\b/\n                });\n                Prism.languages.insertBefore('cpp', 'string', {\n                  'raw-string': {\n                    pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n                    alias: 'string',\n                    greedy: true\n                  }\n                });\n                Prism.languages.insertBefore('cpp', 'class-name', {\n                  'base-clause': {\n                    pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n                    lookbehind: true,\n                    greedy: true,\n                    inside: Prism.languages.extend('cpp', {})\n                  }\n                });\n                Prism.languages.insertBefore('inside', 'operator', { 'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i }, Prism.languages.cpp['base-clause']);\n              }(Prism));\n            },\n            {}\n          ],\n          5: [\n            function (require, module, exports) {\n              (function (Prism) {\n                function replace(pattern, replacements) {\n                  return pattern.replace(/<<(\\d+)>>/g, function (m, index) {\n                    return '(?:' + replacements[+index] + ')';\n                  });\n                }\n                function re(pattern, replacements, flags) {\n                  return RegExp(replace(pattern, replacements), flags || '');\n                }\n                function nested(pattern, depthLog2) {\n                  for (var i = 0; i < depthLog2; i++) {\n                    pattern = pattern.replace(/<<self>>/g, function () {\n                      return '(?:' + pattern + ')';\n                    });\n                  }\n                  return pattern.replace(/<<self>>/g, '[^\\\\s\\\\S]');\n                }\n                var keywordKinds = {\n                  type: 'bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void',\n                  typeDeclaration: 'class enum interface struct',\n                  contextual: 'add alias and ascending async await by descending from get global group into join let nameof not notnull on or orderby partial remove select set unmanaged value when where',\n                  other: 'abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield'\n                };\n                function keywordsToPattern(words) {\n                  return '\\\\b(?:' + words.trim().replace(/ /g, '|') + ')\\\\b';\n                }\n                var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);\n                var keywords = RegExp(keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other));\n                var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other);\n                var nonContextualKeywords = keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.other);\n                var generic = nested(/<(?:[^<>;=+\\-*/%&|^]|<<self>>)*>/.source, 2);\n                var nestedRound = nested(/\\((?:[^()]|<<self>>)*\\)/.source, 2);\n                var name = /@?\\b[A-Za-z_]\\w*\\b/.source;\n                var genericName = replace(/<<0>>(?:\\s*<<1>>)?/.source, [\n                  name,\n                  generic\n                ]);\n                var identifier = replace(/(?!<<0>>)<<1>>(?:\\s*\\.\\s*<<1>>)*/.source, [\n                  nonTypeKeywords,\n                  genericName\n                ]);\n                var array = /\\[\\s*(?:,\\s*)*\\]/.source;\n                var typeExpressionWithoutTuple = replace(/<<0>>(?:\\s*(?:\\?\\s*)?<<1>>)*(?:\\s*\\?)?/.source, [\n                  identifier,\n                  array\n                ]);\n                var tupleElement = replace(/[^,()<>[\\];=+\\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [\n                  generic,\n                  nestedRound,\n                  array\n                ]);\n                var tuple = replace(/\\(<<0>>+(?:,<<0>>+)+\\)/.source, [tupleElement]);\n                var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\\s*(?:\\?\\s*)?<<2>>)*(?:\\s*\\?)?/.source, [\n                  tuple,\n                  identifier,\n                  array\n                ]);\n                var typeInside = {\n                  'keyword': keywords,\n                  'punctuation': /[<>()?,.:[\\]]/\n                };\n                var character = /'(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'/.source;\n                var regularString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/.source;\n                var verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\n                Prism.languages.csharp = Prism.languages.extend('clike', {\n                  'string': [\n                    {\n                      pattern: re(/(^|[^$\\\\])<<0>>/.source, [verbatimString]),\n                      lookbehind: true,\n                      greedy: true\n                    },\n                    {\n                      pattern: re(/(^|[^@$\\\\])<<0>>/.source, [regularString]),\n                      lookbehind: true,\n                      greedy: true\n                    },\n                    {\n                      pattern: RegExp(character),\n                      greedy: true,\n                      alias: 'character'\n                    }\n                  ],\n                  'class-name': [\n                    {\n                      pattern: re(/(\\busing\\s+static\\s+)<<0>>(?=\\s*;)/.source, [identifier]),\n                      lookbehind: true,\n                      inside: typeInside\n                    },\n                    {\n                      pattern: re(/(\\busing\\s+<<0>>\\s*=\\s*)<<1>>(?=\\s*;)/.source, [\n                        name,\n                        typeExpression\n                      ]),\n                      lookbehind: true,\n                      inside: typeInside\n                    },\n                    {\n                      pattern: re(/(\\busing\\s+)<<0>>(?=\\s*=)/.source, [name]),\n                      lookbehind: true\n                    },\n                    {\n                      pattern: re(/(\\b<<0>>\\s+)<<1>>/.source, [\n                        typeDeclarationKeywords,\n                        genericName\n                      ]),\n                      lookbehind: true,\n                      inside: typeInside\n                    },\n                    {\n                      pattern: re(/(\\bcatch\\s*\\(\\s*)<<0>>/.source, [identifier]),\n                      lookbehind: true,\n                      inside: typeInside\n                    },\n                    {\n                      pattern: re(/(\\bwhere\\s+)<<0>>/.source, [name]),\n                      lookbehind: true\n                    },\n                    {\n                      pattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<<0>>/.source, [typeExpressionWithoutTuple]),\n                      lookbehind: true,\n                      inside: typeInside\n                    },\n                    {\n                      pattern: re(/\\b<<0>>(?=\\s+(?!<<1>>)<<2>>(?:\\s*[=,;:{)\\]]|\\s+(?:in|when)\\b))/.source, [\n                        typeExpression,\n                        nonContextualKeywords,\n                        name\n                      ]),\n                      inside: typeInside\n                    }\n                  ],\n                  'keyword': keywords,\n                  'number': /(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:ul|lu|[dflmu])?\\b/i,\n                  'operator': />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n                  'punctuation': /\\?\\.?|::|[{}[\\];(),.:]/\n                });\n                Prism.languages.insertBefore('csharp', 'number', {\n                  'range': {\n                    pattern: /\\.\\./,\n                    alias: 'operator'\n                  }\n                });\n                Prism.languages.insertBefore('csharp', 'punctuation', {\n                  'named-parameter': {\n                    pattern: re(/([(,]\\s*)<<0>>(?=\\s*:)/.source, [name]),\n                    lookbehind: true,\n                    alias: 'punctuation'\n                  }\n                });\n                Prism.languages.insertBefore('csharp', 'class-name', {\n                  'namespace': {\n                    pattern: re(/(\\b(?:namespace|using)\\s+)<<0>>(?:\\s*\\.\\s*<<0>>)*(?=\\s*[;{])/.source, [name]),\n                    lookbehind: true,\n                    inside: { 'punctuation': /\\./ }\n                  },\n                  'type-expression': {\n                    pattern: re(/(\\b(?:default|typeof|sizeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<<0>>)*(?=\\s*\\))/.source, [nestedRound]),\n                    lookbehind: true,\n                    alias: 'class-name',\n                    inside: typeInside\n                  },\n                  'return-type': {\n                    pattern: re(/<<0>>(?=\\s+(?:<<1>>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source, [\n                      typeExpression,\n                      identifier\n                    ]),\n                    inside: typeInside,\n                    alias: 'class-name'\n                  },\n                  'constructor-invocation': {\n                    pattern: re(/(\\bnew\\s+)<<0>>(?=\\s*[[({])/.source, [typeExpression]),\n                    lookbehind: true,\n                    inside: typeInside,\n                    alias: 'class-name'\n                  },\n                  'generic-method': {\n                    pattern: re(/<<0>>\\s*<<1>>(?=\\s*\\()/.source, [\n                      name,\n                      generic\n                    ]),\n                    inside: {\n                      'function': re(/^<<0>>/.source, [name]),\n                      'generic': {\n                        pattern: RegExp(generic),\n                        alias: 'class-name',\n                        inside: typeInside\n                      }\n                    }\n                  },\n                  'type-list': {\n                    pattern: re(/\\b((?:<<0>>\\s+<<1>>|where\\s+<<2>>)\\s*:\\s*)(?:<<3>>|<<4>>)(?:\\s*,\\s*(?:<<3>>|<<4>>))*(?=\\s*(?:where|[{;]|=>|$))/.source, [\n                      typeDeclarationKeywords,\n                      genericName,\n                      name,\n                      typeExpression,\n                      keywords.source\n                    ]),\n                    lookbehind: true,\n                    inside: {\n                      'keyword': keywords,\n                      'class-name': {\n                        pattern: RegExp(typeExpression),\n                        greedy: true,\n                        inside: typeInside\n                      },\n                      'punctuation': /,/\n                    }\n                  },\n                  'preprocessor': {\n                    pattern: /(^\\s*)#.*/m,\n                    lookbehind: true,\n                    alias: 'property',\n                    inside: {\n                      'directive': {\n                        pattern: /(\\s*#)\\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\\b/,\n                        lookbehind: true,\n                        alias: 'keyword'\n                      }\n                    }\n                  }\n                });\n                var regularStringOrCharacter = regularString + '|' + character;\n                var regularStringCharacterOrComment = replace(/\\/(?![*/])|\\/\\/[^\\r\\n]*[\\r\\n]|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>/.source, [regularStringOrCharacter]);\n                var roundExpression = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [regularStringCharacterOrComment]), 2);\n                var attrTarget = /\\b(?:assembly|event|field|method|module|param|property|return|type)\\b/.source;\n                var attr = replace(/<<0>>(?:\\s*\\(<<1>>*\\))?/.source, [\n                  identifier,\n                  roundExpression\n                ]);\n                Prism.languages.insertBefore('csharp', 'class-name', {\n                  'attribute': {\n                    pattern: re(/((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<<0>>\\s*:\\s*)?<<1>>(?:\\s*,\\s*<<1>>)*(?=\\s*\\])/.source, [\n                      attrTarget,\n                      attr\n                    ]),\n                    lookbehind: true,\n                    greedy: true,\n                    inside: {\n                      'target': {\n                        pattern: re(/^<<0>>(?=\\s*:)/.source, [attrTarget]),\n                        alias: 'keyword'\n                      },\n                      'attribute-arguments': {\n                        pattern: re(/\\(<<0>>*\\)/.source, [roundExpression]),\n                        inside: Prism.languages.csharp\n                      },\n                      'class-name': {\n                        pattern: RegExp(identifier),\n                        inside: { 'punctuation': /\\./ }\n                      },\n                      'punctuation': /[:,]/\n                    }\n                  }\n                });\n                var formatString = /:[^}\\r\\n]+/.source;\n                var mInterpolationRound = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [regularStringCharacterOrComment]), 2);\n                var mInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n                  mInterpolationRound,\n                  formatString\n                ]);\n                var sInterpolationRound = nested(replace(/[^\"'/()]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>|\\(<<self>>*\\)/.source, [regularStringOrCharacter]), 2);\n                var sInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n                  sInterpolationRound,\n                  formatString\n                ]);\n                function createInterpolationInside(interpolation, interpolationRound) {\n                  return {\n                    'interpolation': {\n                      pattern: re(/((?:^|[^{])(?:\\{\\{)*)<<0>>/.source, [interpolation]),\n                      lookbehind: true,\n                      inside: {\n                        'format-string': {\n                          pattern: re(/(^\\{(?:(?![}:])<<0>>)*)<<1>>(?=\\}$)/.source, [\n                            interpolationRound,\n                            formatString\n                          ]),\n                          lookbehind: true,\n                          inside: { 'punctuation': /^:/ }\n                        },\n                        'punctuation': /^\\{|\\}$/,\n                        'expression': {\n                          pattern: /[\\s\\S]+/,\n                          alias: 'language-csharp',\n                          inside: Prism.languages.csharp\n                        }\n                      }\n                    },\n                    'string': /[\\s\\S]+/\n                  };\n                }\n                Prism.languages.insertBefore('csharp', 'string', {\n                  'interpolation-string': [\n                    {\n                      pattern: re(/(^|[^\\\\])(?:\\$@|@\\$)\"(?:\"\"|\\\\[\\s\\S]|\\{\\{|<<0>>|[^\\\\{\"])*\"/.source, [mInterpolation]),\n                      lookbehind: true,\n                      greedy: true,\n                      inside: createInterpolationInside(mInterpolation, mInterpolationRound)\n                    },\n                    {\n                      pattern: re(/(^|[^@\\\\])\\$\"(?:\\\\.|\\{\\{|<<0>>|[^\\\\\"{])*\"/.source, [sInterpolation]),\n                      lookbehind: true,\n                      greedy: true,\n                      inside: createInterpolationInside(sInterpolation, sInterpolationRound)\n                    }\n                  ]\n                });\n              }(Prism));\n              Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;\n            },\n            {}\n          ],\n          6: [\n            function (require, module, exports) {\n              (function (Prism) {\n                var string = /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;\n                Prism.languages.css = {\n                  'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n                  'atrule': {\n                    pattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n                    inside: {\n                      'rule': /^@[\\w-]+/,\n                      'selector-function-argument': {\n                        pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n                        lookbehind: true,\n                        alias: 'selector'\n                      },\n                      'keyword': {\n                        pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n                        lookbehind: true\n                      }\n                    }\n                  },\n                  'url': {\n                    pattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n                    greedy: true,\n                    inside: {\n                      'function': /^url/i,\n                      'punctuation': /^\\(|\\)$/,\n                      'string': {\n                        pattern: RegExp('^' + string.source + '$'),\n                        alias: 'url'\n                      }\n                    }\n                  },\n                  'selector': RegExp('[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n                  'string': {\n                    pattern: string,\n                    greedy: true\n                  },\n                  'property': /(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n                  'important': /!important\\b/i,\n                  'function': /[-a-z0-9]+(?=\\()/i,\n                  'punctuation': /[(){};:,]/\n                };\n                Prism.languages.css['atrule'].inside.rest = Prism.languages.css;\n                var markup = Prism.languages.markup;\n                if (markup) {\n                  markup.tag.addInlined('style', 'css');\n                  Prism.languages.insertBefore('inside', 'attr-value', {\n                    'style-attr': {\n                      pattern: /(^|[\"'\\s])style\\s*=\\s*(?:\"[^\"]*\"|'[^']*')/i,\n                      lookbehind: true,\n                      inside: {\n                        'attr-value': {\n                          pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n                          inside: {\n                            'style': {\n                              pattern: /([\"'])[\\s\\S]+(?=[\"']$)/,\n                              lookbehind: true,\n                              alias: 'language-css',\n                              inside: Prism.languages.css\n                            },\n                            'punctuation': [\n                              {\n                                pattern: /^=/,\n                                alias: 'attr-equals'\n                              },\n                              /\"|'/\n                            ]\n                          }\n                        },\n                        'attr-name': /^style/i\n                      }\n                    }\n                  }, markup.tag);\n                }\n              }(Prism));\n            },\n            {}\n          ],\n          7: [\n            function (require, module, exports) {\n              (function (Prism) {\n                var keywords = /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/;\n                var classNamePrefix = /(^|[^\\w.])(?:[a-z]\\w*\\s*\\.\\s*)*(?:[A-Z]\\w*\\s*\\.\\s*)*/.source;\n                var className = {\n                  pattern: RegExp(classNamePrefix + /[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b/.source),\n                  lookbehind: true,\n                  inside: {\n                    'namespace': {\n                      pattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,\n                      inside: { 'punctuation': /\\./ }\n                    },\n                    'punctuation': /\\./\n                  }\n                };\n                Prism.languages.java = Prism.languages.extend('clike', {\n                  'class-name': [\n                    className,\n                    {\n                      pattern: RegExp(classNamePrefix + /[A-Z]\\w*(?=\\s+\\w+\\s*[;,=())])/.source),\n                      lookbehind: true,\n                      inside: className.inside\n                    }\n                  ],\n                  'keyword': keywords,\n                  'function': [\n                    Prism.languages.clike.function,\n                    {\n                      pattern: /(\\:\\:\\s*)[a-z_]\\w*/,\n                      lookbehind: true\n                    }\n                  ],\n                  'number': /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,\n                  'operator': {\n                    pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,\n                    lookbehind: true\n                  }\n                });\n                Prism.languages.insertBefore('java', 'string', {\n                  'triple-quoted-string': {\n                    pattern: /\"\"\"[ \\t]*[\\r\\n](?:(?:\"|\"\")?(?:\\\\.|[^\"\\\\]))*\"\"\"/,\n                    greedy: true,\n                    alias: 'string'\n                  }\n                });\n                Prism.languages.insertBefore('java', 'class-name', {\n                  'annotation': {\n                    pattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/,\n                    lookbehind: true,\n                    alias: 'punctuation'\n                  },\n                  'generics': {\n                    pattern: /<(?:[\\w\\s,.&?]|<(?:[\\w\\s,.&?]|<(?:[\\w\\s,.&?]|<[\\w\\s,.&?]*>)*>)*>)*>/,\n                    inside: {\n                      'class-name': className,\n                      'keyword': keywords,\n                      'punctuation': /[<>(),.:]/,\n                      'operator': /[?&|]/\n                    }\n                  },\n                  'namespace': {\n                    pattern: RegExp(/(\\b(?:exports|import(?:\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\s+)(?!<keyword>)[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?/.source.replace(/<keyword>/g, function () {\n                      return keywords.source;\n                    })),\n                    lookbehind: true,\n                    inside: { 'punctuation': /\\./ }\n                  }\n                });\n              }(Prism));\n            },\n            {}\n          ],\n          8: [\n            function (require, module, exports) {\n              Prism.languages.javascript = Prism.languages.extend('clike', {\n                'class-name': [\n                  Prism.languages.clike['class-name'],\n                  {\n                    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:prototype|constructor))/,\n                    lookbehind: true\n                  }\n                ],\n                'keyword': [\n                  {\n                    pattern: /((?:^|})\\s*)(?:catch|finally)\\b/,\n                    lookbehind: true\n                  },\n                  {\n                    pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\\s*[\\[$\\w\\xA0-\\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n                    lookbehind: true\n                  }\n                ],\n                'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n                'number': /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,\n                'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n              });\n              Prism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/;\n              Prism.languages.insertBefore('javascript', 'keyword', {\n                'regex': {\n                  pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyus]{0,6}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,\n                  lookbehind: true,\n                  greedy: true,\n                  inside: {\n                    'regex-source': {\n                      pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n                      lookbehind: true,\n                      alias: 'language-regex',\n                      inside: Prism.languages.regex\n                    },\n                    'regex-flags': /[a-z]+$/,\n                    'regex-delimiter': /^\\/|\\/$/\n                  }\n                },\n                'function-variable': {\n                  pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n                  alias: 'function'\n                },\n                'parameter': [\n                  {\n                    pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n                    lookbehind: true,\n                    inside: Prism.languages.javascript\n                  },\n                  {\n                    pattern: /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n                    inside: Prism.languages.javascript\n                  },\n                  {\n                    pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n                    lookbehind: true,\n                    inside: Prism.languages.javascript\n                  },\n                  {\n                    pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n                    lookbehind: true,\n                    inside: Prism.languages.javascript\n                  }\n                ],\n                'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n              });\n              Prism.languages.insertBefore('javascript', 'string', {\n                'template-string': {\n                  pattern: /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\\${)[^\\\\`])*`/,\n                  greedy: true,\n                  inside: {\n                    'template-punctuation': {\n                      pattern: /^`|`$/,\n                      alias: 'string'\n                    },\n                    'interpolation': {\n                      pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,\n                      lookbehind: true,\n                      inside: {\n                        'interpolation-punctuation': {\n                          pattern: /^\\${|}$/,\n                          alias: 'punctuation'\n                        },\n                        rest: Prism.languages.javascript\n                      }\n                    },\n                    'string': /[\\s\\S]+/\n                  }\n                }\n              });\n              if (Prism.languages.markup) {\n                Prism.languages.markup.tag.addInlined('script', 'javascript');\n              }\n              Prism.languages.js = Prism.languages.javascript;\n            },\n            {}\n          ],\n          9: [\n            function (require, module, exports) {\n              (function (Prism) {\n                function getPlaceholder(language, index) {\n                  return '___' + language.toUpperCase() + index + '___';\n                }\n                Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n                  buildPlaceholders: {\n                    value: function (env, language, placeholderPattern, replaceFilter) {\n                      if (env.language !== language) {\n                        return;\n                      }\n                      var tokenStack = env.tokenStack = [];\n                      env.code = env.code.replace(placeholderPattern, function (match) {\n                        if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n                          return match;\n                        }\n                        var i = tokenStack.length;\n                        var placeholder;\n                        while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1)\n                          ++i;\n                        tokenStack[i] = match;\n                        return placeholder;\n                      });\n                      env.grammar = Prism.languages.markup;\n                    }\n                  },\n                  tokenizePlaceholders: {\n                    value: function (env, language) {\n                      if (env.language !== language || !env.tokenStack) {\n                        return;\n                      }\n                      env.grammar = Prism.languages[language];\n                      var j = 0;\n                      var keys = Object.keys(env.tokenStack);\n                      function walkTokens(tokens) {\n                        for (var i = 0; i < tokens.length; i++) {\n                          if (j >= keys.length) {\n                            break;\n                          }\n                          var token = tokens[i];\n                          if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n                            var k = keys[j];\n                            var t = env.tokenStack[k];\n                            var s = typeof token === 'string' ? token : token.content;\n                            var placeholder = getPlaceholder(language, k);\n                            var index = s.indexOf(placeholder);\n                            if (index > -1) {\n                              ++j;\n                              var before = s.substring(0, index);\n                              var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                              var after = s.substring(index + placeholder.length);\n                              var replacement = [];\n                              if (before) {\n                                replacement.push.apply(replacement, walkTokens([before]));\n                              }\n                              replacement.push(middle);\n                              if (after) {\n                                replacement.push.apply(replacement, walkTokens([after]));\n                              }\n                              if (typeof token === 'string') {\n                                tokens.splice.apply(tokens, [\n                                  i,\n                                  1\n                                ].concat(replacement));\n                              } else {\n                                token.content = replacement;\n                              }\n                            }\n                          } else if (token.content) {\n                            walkTokens(token.content);\n                          }\n                        }\n                        return tokens;\n                      }\n                      walkTokens(env.tokens);\n                    }\n                  }\n                });\n              }(Prism));\n            },\n            {}\n          ],\n          10: [\n            function (require, module, exports) {\n              Prism.languages.markup = {\n                'comment': /\x3c!--[\\s\\S]*?--\x3e/,\n                'prolog': /<\\?[\\s\\S]+?\\?>/,\n                'doctype': {\n                  pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|\x3c!--(?:[^-]|-(?!->))*--\x3e)*\\]\\s*)?>/i,\n                  greedy: true,\n                  inside: {\n                    'internal-subset': {\n                      pattern: /(\\[)[\\s\\S]+(?=\\]>$)/,\n                      lookbehind: true,\n                      greedy: true,\n                      inside: null\n                    },\n                    'string': {\n                      pattern: /\"[^\"]*\"|'[^']*'/,\n                      greedy: true\n                    },\n                    'punctuation': /^<!|>$|[[\\]]/,\n                    'doctype-tag': /^DOCTYPE/,\n                    'name': /[^\\s<>'\"]+/\n                  }\n                },\n                'cdata': /<!\\[CDATA\\[[\\s\\S]*?]]>/i,\n                'tag': {\n                  pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n                  greedy: true,\n                  inside: {\n                    'tag': {\n                      pattern: /^<\\/?[^\\s>\\/]+/,\n                      inside: {\n                        'punctuation': /^<\\/?/,\n                        'namespace': /^[^\\s>\\/:]+:/\n                      }\n                    },\n                    'attr-value': {\n                      pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n                      inside: {\n                        'punctuation': [\n                          {\n                            pattern: /^=/,\n                            alias: 'attr-equals'\n                          },\n                          /\"|'/\n                        ]\n                      }\n                    },\n                    'punctuation': /\\/?>/,\n                    'attr-name': {\n                      pattern: /[^\\s>\\/]+/,\n                      inside: { 'namespace': /^[^\\s>\\/:]+:/ }\n                    }\n                  }\n                },\n                'entity': [\n                  {\n                    pattern: /&[\\da-z]{1,8};/i,\n                    alias: 'named-entity'\n                  },\n                  /&#x?[\\da-f]{1,8};/i\n                ]\n              };\n              Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] = Prism.languages.markup['entity'];\n              Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n              Prism.hooks.add('wrap', function (env) {\n                if (env.type === 'entity') {\n                  env.attributes['title'] = env.content.replace(/&amp;/, '&');\n                }\n              });\n              Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n                value: function addInlined(tagName, lang) {\n                  var includedCdataInside = {};\n                  includedCdataInside['language-' + lang] = {\n                    pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n                    lookbehind: true,\n                    inside: Prism.languages[lang]\n                  };\n                  includedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n                  var inside = {\n                    'included-cdata': {\n                      pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n                      inside: includedCdataInside\n                    }\n                  };\n                  inside['language-' + lang] = {\n                    pattern: /[\\s\\S]+/,\n                    inside: Prism.languages[lang]\n                  };\n                  var def = {};\n                  def[tagName] = {\n                    pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () {\n                      return tagName;\n                    }), 'i'),\n                    lookbehind: true,\n                    greedy: true,\n                    inside: inside\n                  };\n                  Prism.languages.insertBefore('markup', 'cdata', def);\n                }\n              });\n              Prism.languages.html = Prism.languages.markup;\n              Prism.languages.mathml = Prism.languages.markup;\n              Prism.languages.svg = Prism.languages.markup;\n              Prism.languages.xml = Prism.languages.extend('markup', {});\n              Prism.languages.ssml = Prism.languages.xml;\n              Prism.languages.atom = Prism.languages.xml;\n              Prism.languages.rss = Prism.languages.xml;\n            },\n            {}\n          ],\n          11: [\n            function (require, module, exports) {\n              (function (Prism) {\n                var comment = /\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*|#(?!\\[).*/;\n                var constant = [\n                  {\n                    pattern: /\\b(?:false|true)\\b/i,\n                    alias: 'boolean'\n                  },\n                  /\\b[A-Z_][A-Z0-9_]*\\b(?!\\s*\\()/,\n                  /\\b(?:null)\\b/i\n                ];\n                var number = /\\b0b[01]+\\b|\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i;\n                var operator = /<?=>|\\?\\?=?|\\.{3}|\\??->|[!=]=?=?|::|\\*\\*=?|--|\\+\\+|&&|\\|\\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;\n                var punctuation = /[{}\\[\\](),:;]/;\n                Prism.languages.php = {\n                  'delimiter': {\n                    pattern: /\\?>$|^<\\?(?:php(?=\\s)|=)?/i,\n                    alias: 'important'\n                  },\n                  'comment': comment,\n                  'variable': /\\$+(?:\\w+\\b|(?={))/i,\n                  'package': {\n                    pattern: /(namespace\\s+|use\\s+(?:function\\s+)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n                    lookbehind: true,\n                    inside: { 'punctuation': /\\\\/ }\n                  },\n                  'keyword': [\n                    {\n                      pattern: /(\\(\\s*)\\b(?:bool|boolean|int|integer|float|string|object|array)\\b(?=\\s*\\))/i,\n                      alias: 'type-casting',\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /([(,?]\\s*)\\b(?:bool|int|float|string|object|array(?!\\s*\\()|mixed|self|static|callable|iterable|(?:null|false)(?=\\s*\\|))\\b(?=\\s*\\$)/i,\n                      alias: 'type-hint',\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /([(,?]\\s*[a-z0-9_|]\\|\\s*)(?:null|false)\\b(?=\\s*\\$)/i,\n                      alias: 'type-hint',\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b(?:bool|int|float|string|object|void|array(?!\\s*\\()|mixed|self|static|callable|iterable|(?:null|false)(?=\\s*\\|))\\b/i,\n                      alias: 'return-type',\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?[a-z0-9_|]\\|\\s*)(?:null|false)\\b/i,\n                      alias: 'return-type',\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /\\b(?:bool|int|float|string|object|void|array(?!\\s*\\()|mixed|iterable|(?:null|false)(?=\\s*\\|))\\b/i,\n                      alias: 'type-declaration',\n                      greedy: true\n                    },\n                    {\n                      pattern: /(\\|\\s*)(?:null|false)\\b/i,\n                      alias: 'type-declaration',\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /\\b(?:parent|self|static)(?=\\s*::)/i,\n                      alias: 'static-context',\n                      greedy: true\n                    },\n                    /\\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|class|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|eval|exit|extends|final|finally|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|match|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\\b/i\n                  ],\n                  'argument-name': /\\b[a-z_]\\w*(?=\\s*:(?!:))/i,\n                  'class-name': [\n                    {\n                      pattern: /(\\b(?:class|interface|extends|implements|trait|instanceof|new(?!\\s+self|\\s+static))\\s+|\\bcatch\\s*\\()\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /(\\|\\s*)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /\\b[a-z_]\\w*(?!\\\\)\\b(?=\\s*\\|)/i,\n                      greedy: true\n                    },\n                    {\n                      pattern: /(\\|\\s*)(?:\\\\?\\b[a-z_]\\w*)+\\b/i,\n                      alias: 'class-name-fully-qualified',\n                      greedy: true,\n                      lookbehind: true,\n                      inside: { 'punctuation': /\\\\/ }\n                    },\n                    {\n                      pattern: /(?:\\\\?\\b[a-z_]\\w*)+\\b(?=\\s*\\|)/i,\n                      alias: 'class-name-fully-qualified',\n                      greedy: true,\n                      inside: { 'punctuation': /\\\\/ }\n                    },\n                    {\n                      pattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self\\b|\\s+static\\b))\\s+|\\bcatch\\s*\\()(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n                      alias: 'class-name-fully-qualified',\n                      greedy: true,\n                      lookbehind: true,\n                      inside: { 'punctuation': /\\\\/ }\n                    },\n                    {\n                      pattern: /\\b[a-z_]\\w*(?=\\s*\\$)/i,\n                      alias: 'type-declaration',\n                      greedy: true\n                    },\n                    {\n                      pattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n                      alias: [\n                        'class-name-fully-qualified',\n                        'type-declaration'\n                      ],\n                      greedy: true,\n                      inside: { 'punctuation': /\\\\/ }\n                    },\n                    {\n                      pattern: /\\b[a-z_]\\w*(?=\\s*::)/i,\n                      alias: 'static-context',\n                      greedy: true\n                    },\n                    {\n                      pattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*::)/i,\n                      alias: [\n                        'class-name-fully-qualified',\n                        'static-context'\n                      ],\n                      greedy: true,\n                      inside: { 'punctuation': /\\\\/ }\n                    },\n                    {\n                      pattern: /([(,?]\\s*)[a-z_]\\w*(?=\\s*\\$)/i,\n                      alias: 'type-hint',\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /([(,?]\\s*)(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n                      alias: [\n                        'class-name-fully-qualified',\n                        'type-hint'\n                      ],\n                      greedy: true,\n                      lookbehind: true,\n                      inside: { 'punctuation': /\\\\/ }\n                    },\n                    {\n                      pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                      alias: 'return-type',\n                      greedy: true,\n                      lookbehind: true\n                    },\n                    {\n                      pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n                      alias: [\n                        'class-name-fully-qualified',\n                        'return-type'\n                      ],\n                      greedy: true,\n                      lookbehind: true,\n                      inside: { 'punctuation': /\\\\/ }\n                    }\n                  ],\n                  'constant': constant,\n                  'function': /\\w+\\s*(?=\\()/,\n                  'property': {\n                    pattern: /(->)[\\w]+/,\n                    lookbehind: true\n                  },\n                  'number': number,\n                  'operator': operator,\n                  'punctuation': punctuation\n                };\n                var string_interpolation = {\n                  pattern: /{\\$(?:{(?:{[^{}]+}|[^{}]+)}|[^{}])+}|(^|[^\\\\{])\\$+(?:\\w+(?:\\[[^\\r\\n\\[\\]]+\\]|->\\w+)*)/,\n                  lookbehind: true,\n                  inside: Prism.languages.php\n                };\n                var string = [\n                  {\n                    pattern: /<<<'([^']+)'[\\r\\n](?:.*[\\r\\n])*?\\1;/,\n                    alias: 'nowdoc-string',\n                    greedy: true,\n                    inside: {\n                      'delimiter': {\n                        pattern: /^<<<'[^']+'|[a-z_]\\w*;$/i,\n                        alias: 'symbol',\n                        inside: { 'punctuation': /^<<<'?|[';]$/ }\n                      }\n                    }\n                  },\n                  {\n                    pattern: /<<<(?:\"([^\"]+)\"[\\r\\n](?:.*[\\r\\n])*?\\1;|([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?\\2;)/i,\n                    alias: 'heredoc-string',\n                    greedy: true,\n                    inside: {\n                      'delimiter': {\n                        pattern: /^<<<(?:\"[^\"]+\"|[a-z_]\\w*)|[a-z_]\\w*;$/i,\n                        alias: 'symbol',\n                        inside: { 'punctuation': /^<<<\"?|[\";]$/ }\n                      },\n                      'interpolation': string_interpolation\n                    }\n                  },\n                  {\n                    pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n                    alias: 'backtick-quoted-string',\n                    greedy: true\n                  },\n                  {\n                    pattern: /'(?:\\\\[\\s\\S]|[^\\\\'])*'/,\n                    alias: 'single-quoted-string',\n                    greedy: true\n                  },\n                  {\n                    pattern: /\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"/,\n                    alias: 'double-quoted-string',\n                    greedy: true,\n                    inside: { 'interpolation': string_interpolation }\n                  }\n                ];\n                Prism.languages.insertBefore('php', 'variable', { 'string': string });\n                Prism.languages.insertBefore('php', 'variable', {\n                  'attribute': {\n                    pattern: /#\\[(?:[^\"'\\/#]|\\/(?![*/])|\\/\\/.*$|#(?!\\[).*$|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*')+\\](?=\\s*[a-z$#])/mi,\n                    greedy: true,\n                    inside: {\n                      'attribute-content': {\n                        pattern: /^(#\\[)[\\s\\S]+(?=]$)/,\n                        lookbehind: true,\n                        inside: {\n                          'comment': comment,\n                          'string': string,\n                          'attribute-class-name': [\n                            {\n                              pattern: /([^:]|^)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                              alias: 'class-name',\n                              greedy: true,\n                              lookbehind: true\n                            },\n                            {\n                              pattern: /([^:]|^)(?:\\\\?\\b[a-z_]\\w*)+/i,\n                              alias: [\n                                'class-name',\n                                'class-name-fully-qualified'\n                              ],\n                              greedy: true,\n                              lookbehind: true,\n                              inside: { 'punctuation': /\\\\/ }\n                            }\n                          ],\n                          'constant': constant,\n                          'number': number,\n                          'operator': operator,\n                          'punctuation': punctuation\n                        }\n                      },\n                      'delimiter': {\n                        pattern: /^#\\[|]$/,\n                        alias: 'punctuation'\n                      }\n                    }\n                  }\n                });\n                Prism.hooks.add('before-tokenize', function (env) {\n                  if (!/<\\?/.test(env.code)) {\n                    return;\n                  }\n                  var phpPattern = /<\\?(?:[^\"'/#]|\\/(?![*/])|(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|(?:\\/\\/|#(?!\\[))(?:[^?\\n\\r]|\\?(?!>))*(?=$|\\?>|[\\r\\n])|#\\[|\\/\\*(?:[^*]|\\*(?!\\/))*(?:\\*\\/|$))*?(?:\\?>|$)/ig;\n                  Prism.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);\n                });\n                Prism.hooks.add('after-tokenize', function (env) {\n                  Prism.languages['markup-templating'].tokenizePlaceholders(env, 'php');\n                });\n              }(Prism));\n            },\n            {}\n          ],\n          12: [\n            function (require, module, exports) {\n              Prism.languages.python = {\n                'comment': {\n                  pattern: /(^|[^\\\\])#.*/,\n                  lookbehind: true\n                },\n                'string-interpolation': {\n                  pattern: /(?:f|rf|fr)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n                  greedy: true,\n                  inside: {\n                    'interpolation': {\n                      pattern: /((?:^|[^{])(?:{{)*){(?!{)(?:[^{}]|{(?!{)(?:[^{}]|{(?!{)(?:[^{}])+})+})+}/,\n                      lookbehind: true,\n                      inside: {\n                        'format-spec': {\n                          pattern: /(:)[^:(){}]+(?=}$)/,\n                          lookbehind: true\n                        },\n                        'conversion-option': {\n                          pattern: /![sra](?=[:}]$)/,\n                          alias: 'punctuation'\n                        },\n                        rest: null\n                      }\n                    },\n                    'string': /[\\s\\S]+/\n                  }\n                },\n                'triple-quoted-string': {\n                  pattern: /(?:[rub]|rb|br)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n                  greedy: true,\n                  alias: 'string'\n                },\n                'string': {\n                  pattern: /(?:[rub]|rb|br)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n                  greedy: true\n                },\n                'function': {\n                  pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n                  lookbehind: true\n                },\n                'class-name': {\n                  pattern: /(\\bclass\\s+)\\w+/i,\n                  lookbehind: true\n                },\n                'decorator': {\n                  pattern: /(^\\s*)@\\w+(?:\\.\\w+)*/im,\n                  lookbehind: true,\n                  alias: [\n                    'annotation',\n                    'punctuation'\n                  ],\n                  inside: { 'punctuation': /\\./ }\n                },\n                'keyword': /\\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n                'builtin': /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n                'boolean': /\\b(?:True|False|None)\\b/,\n                'number': /(?:\\b(?=\\d)|\\B(?=\\.))(?:0[bo])?(?:(?:\\d|0x[\\da-f])[\\da-f]*(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?j?\\b/i,\n                'operator': /[-+%=]=?|!=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n                'punctuation': /[{}[\\];(),.:]/\n              };\n              Prism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;\n              Prism.languages.py = Prism.languages.python;\n            },\n            {}\n          ],\n          13: [\n            function (require, module, exports) {\n              (function (Prism) {\n                Prism.languages.ruby = Prism.languages.extend('clike', {\n                  'comment': [\n                    /#.*/,\n                    {\n                      pattern: /^=begin\\s[\\s\\S]*?^=end/m,\n                      greedy: true\n                    }\n                  ],\n                  'class-name': {\n                    pattern: /(\\b(?:class)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n                    lookbehind: true,\n                    inside: { 'punctuation': /[.\\\\]/ }\n                  },\n                  'keyword': /\\b(?:alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|protected|private|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\\b/\n                });\n                var interpolation = {\n                  pattern: /#\\{[^}]+\\}/,\n                  inside: {\n                    'delimiter': {\n                      pattern: /^#\\{|\\}$/,\n                      alias: 'tag'\n                    },\n                    rest: Prism.languages.ruby\n                  }\n                };\n                delete Prism.languages.ruby.function;\n                Prism.languages.insertBefore('ruby', 'keyword', {\n                  'regex': [\n                    {\n                      pattern: RegExp(/%r/.source + '(?:' + [\n                        /([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1[gim]{0,3}/.source,\n                        /\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)[gim]{0,3}/.source,\n                        /\\{(?:[^#{}\\\\]|#(?:\\{[^}]+\\})?|\\\\[\\s\\S])*\\}[gim]{0,3}/.source,\n                        /\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\][gim]{0,3}/.source,\n                        /<(?:[^<>\\\\]|\\\\[\\s\\S])*>[gim]{0,3}/.source\n                      ].join('|') + ')'),\n                      greedy: true,\n                      inside: { 'interpolation': interpolation }\n                    },\n                    {\n                      pattern: /(^|[^/])\\/(?!\\/)(?:\\[[^\\r\\n\\]]+\\]|\\\\.|[^[/\\\\\\r\\n])+\\/[gim]{0,3}(?=\\s*(?:$|[\\r\\n,.;})]))/,\n                      lookbehind: true,\n                      greedy: true\n                    }\n                  ],\n                  'variable': /[@$]+[a-zA-Z_]\\w*(?:[?!]|\\b)/,\n                  'symbol': {\n                    pattern: /(^|[^:]):[a-zA-Z_]\\w*(?:[?!]|\\b)/,\n                    lookbehind: true\n                  },\n                  'method-definition': {\n                    pattern: /(\\bdef\\s+)[\\w.]+/,\n                    lookbehind: true,\n                    inside: {\n                      'function': /\\w+$/,\n                      rest: Prism.languages.ruby\n                    }\n                  }\n                });\n                Prism.languages.insertBefore('ruby', 'number', {\n                  'builtin': /\\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\\b/,\n                  'constant': /\\b[A-Z]\\w*(?:[?!]|\\b)/\n                });\n                Prism.languages.ruby.string = [\n                  {\n                    pattern: RegExp(/%[qQiIwWxs]?/.source + '(?:' + [\n                      /([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/.source,\n                      /\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)/.source,\n                      /\\{(?:[^#{}\\\\]|#(?:\\{[^}]+\\})?|\\\\[\\s\\S])*\\}/.source,\n                      /\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\]/.source,\n                      /<(?:[^<>\\\\]|\\\\[\\s\\S])*>/.source\n                    ].join('|') + ')'),\n                    greedy: true,\n                    inside: { 'interpolation': interpolation }\n                  },\n                  {\n                    pattern: /(\"|')(?:#\\{[^}]+\\}|#(?!\\{)|\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\#\\r\\n])*\\1/,\n                    greedy: true,\n                    inside: { 'interpolation': interpolation }\n                  }\n                ];\n                Prism.languages.rb = Prism.languages.ruby;\n              }(Prism));\n            },\n            {}\n          ],\n          14: [\n            function (require, module, exports) {\n              var Prism = require('prismjs/components/prism-core');\n              require('prismjs/components/prism-clike');\n              require('prismjs/components/prism-markup-templating');\n              require('prismjs/components/prism-c');\n              require('prismjs/components/prism-cpp');\n              require('prismjs/components/prism-csharp');\n              require('prismjs/components/prism-css');\n              require('prismjs/components/prism-java');\n              require('prismjs/components/prism-javascript');\n              require('prismjs/components/prism-markup');\n              require('prismjs/components/prism-php');\n              require('prismjs/components/prism-python');\n              require('prismjs/components/prism-ruby');\n              module.exports = { boltExport: Prism };\n            },\n            {\n              'prismjs/components/prism-c': 1,\n              'prismjs/components/prism-clike': 2,\n              'prismjs/components/prism-core': 3,\n              'prismjs/components/prism-cpp': 4,\n              'prismjs/components/prism-csharp': 5,\n              'prismjs/components/prism-css': 6,\n              'prismjs/components/prism-java': 7,\n              'prismjs/components/prism-javascript': 8,\n              'prismjs/components/prism-markup': 10,\n              'prismjs/components/prism-markup-templating': 9,\n              'prismjs/components/prism-php': 11,\n              'prismjs/components/prism-python': 12,\n              'prismjs/components/prism-ruby': 13\n            }\n          ]\n        }, {}, [14])(14);\n      }));\n      var prism = window.Prism;\n      window.Prism = oldprism;\n      return prism;\n    }(undefined, exports$1, module, undefined));\n    var Prism$1 = module.exports.boltExport;\n\n    var getLanguages = function (editor) {\n      return editor.getParam('codesample_languages');\n    };\n    var useGlobalPrismJS = function (editor) {\n      return editor.getParam('codesample_global_prismjs', false, 'boolean');\n    };\n\n    var get$1 = function (editor) {\n      return Global.Prism && useGlobalPrismJS(editor) ? Global.Prism : Prism$1;\n    };\n\n    var getSelectedCodeSample = function (editor) {\n      var node = editor.selection ? editor.selection.getNode() : null;\n      if (isCodeSample(node)) {\n        return Optional.some(node);\n      }\n      return Optional.none();\n    };\n    var insertCodeSample = function (editor, language, code) {\n      editor.undoManager.transact(function () {\n        var node = getSelectedCodeSample(editor);\n        code = global$1.DOM.encode(code);\n        return node.fold(function () {\n          editor.insertContent('<pre id=\"__new\" class=\"language-' + language + '\">' + code + '</pre>');\n          editor.selection.select(editor.$('#__new').removeAttr('id')[0]);\n        }, function (n) {\n          editor.dom.setAttrib(n, 'class', 'language-' + language);\n          n.innerHTML = code;\n          get$1(editor).highlightElement(n);\n          editor.selection.select(n);\n        });\n      });\n    };\n    var getCurrentCode = function (editor) {\n      var node = getSelectedCodeSample(editor);\n      return node.fold(function () {\n        return '';\n      }, function (n) {\n        return n.textContent;\n      });\n    };\n\n    var getLanguages$1 = function (editor) {\n      var defaultLanguages = [\n        {\n          text: 'HTML/XML',\n          value: 'markup'\n        },\n        {\n          text: 'JavaScript',\n          value: 'javascript'\n        },\n        {\n          text: 'CSS',\n          value: 'css'\n        },\n        {\n          text: 'PHP',\n          value: 'php'\n        },\n        {\n          text: 'Ruby',\n          value: 'ruby'\n        },\n        {\n          text: 'Python',\n          value: 'python'\n        },\n        {\n          text: 'Java',\n          value: 'java'\n        },\n        {\n          text: 'C',\n          value: 'c'\n        },\n        {\n          text: 'C#',\n          value: 'csharp'\n        },\n        {\n          text: 'C++',\n          value: 'cpp'\n        }\n      ];\n      var customLanguages = getLanguages(editor);\n      return customLanguages ? customLanguages : defaultLanguages;\n    };\n    var getCurrentLanguage = function (editor, fallback) {\n      var node = getSelectedCodeSample(editor);\n      return node.fold(function () {\n        return fallback;\n      }, function (n) {\n        var matches = n.className.match(/language-(\\w+)/);\n        return matches ? matches[1] : fallback;\n      });\n    };\n\n    var open = function (editor) {\n      var languages = getLanguages$1(editor);\n      var defaultLanguage = head(languages).fold(function () {\n        return '';\n      }, function (l) {\n        return l.value;\n      });\n      var currentLanguage = getCurrentLanguage(editor, defaultLanguage);\n      var currentCode = getCurrentCode(editor);\n      editor.windowManager.open({\n        title: 'Insert/Edit Code Sample',\n        size: 'large',\n        body: {\n          type: 'panel',\n          items: [\n            {\n              type: 'selectbox',\n              name: 'language',\n              label: 'Language',\n              items: languages\n            },\n            {\n              type: 'textarea',\n              name: 'code',\n              label: 'Code view'\n            }\n          ]\n        },\n        buttons: [\n          {\n            type: 'cancel',\n            name: 'cancel',\n            text: 'Cancel'\n          },\n          {\n            type: 'submit',\n            name: 'save',\n            text: 'Save',\n            primary: true\n          }\n        ],\n        initialData: {\n          language: currentLanguage,\n          code: currentCode\n        },\n        onSubmit: function (api) {\n          var data = api.getData();\n          insertCodeSample(editor, data.language, data.code);\n          api.close();\n        }\n      });\n    };\n\n    var register = function (editor) {\n      editor.addCommand('codesample', function () {\n        var node = editor.selection.getNode();\n        if (editor.selection.isCollapsed() || isCodeSample(node)) {\n          open(editor);\n        } else {\n          editor.formatter.toggle('code');\n        }\n      });\n    };\n\n    var setup = function (editor) {\n      var $ = editor.$;\n      editor.on('PreProcess', function (e) {\n        $('pre[contenteditable=false]', e.node).filter(trimArg(isCodeSample)).each(function (idx, elm) {\n          var $elm = $(elm), code = elm.textContent;\n          $elm.attr('class', $.trim($elm.attr('class')));\n          $elm.removeAttr('contentEditable');\n          $elm.empty().append($('<code></code>').each(function () {\n            this.textContent = code;\n          }));\n        });\n      });\n      editor.on('SetContent', function () {\n        var unprocessedCodeSamples = $('pre').filter(trimArg(isCodeSample)).filter(function (idx, elm) {\n          return elm.contentEditable !== 'false';\n        });\n        if (unprocessedCodeSamples.length) {\n          editor.undoManager.transact(function () {\n            unprocessedCodeSamples.each(function (idx, elm) {\n              $(elm).find('br').each(function (idx, elm) {\n                elm.parentNode.replaceChild(editor.getDoc().createTextNode('\\n'), elm);\n              });\n              elm.contentEditable = 'false';\n              elm.innerHTML = editor.dom.encode(elm.textContent);\n              get$1(editor).highlightElement(elm);\n              elm.className = $.trim(elm.className);\n            });\n          });\n        }\n      });\n    };\n\n    var isCodeSampleSelection = function (editor) {\n      var node = editor.selection.getStart();\n      return editor.dom.is(node, 'pre[class*=\"language-\"]');\n    };\n    var register$1 = function (editor) {\n      editor.ui.registry.addToggleButton('codesample', {\n        icon: 'code-sample',\n        tooltip: 'Insert/edit code sample',\n        onAction: function () {\n          return open(editor);\n        },\n        onSetup: function (api) {\n          var nodeChangeHandler = function () {\n            api.setActive(isCodeSampleSelection(editor));\n          };\n          editor.on('NodeChange', nodeChangeHandler);\n          return function () {\n            return editor.off('NodeChange', nodeChangeHandler);\n          };\n        }\n      });\n      editor.ui.registry.addMenuItem('codesample', {\n        text: 'Code sample...',\n        icon: 'code-sample',\n        onAction: function () {\n          return open(editor);\n        }\n      });\n    };\n\n    function Plugin () {\n      global.add('codesample', function (editor) {\n        setup(editor);\n        register$1(editor);\n        register(editor);\n        editor.on('dblclick', function (ev) {\n          if (isCodeSample(ev.target)) {\n            open(editor);\n          }\n        });\n      });\n    }\n\n    Plugin();\n\n}());\n\n\n//# sourceURL=webpack:///./src/js/plugins/codesample/plugin.js?")}});